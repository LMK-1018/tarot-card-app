<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æ²‰æµ¸å¼å¡”ç½—æŠ½å¡ (å®Œæ•´æ‰‹åŠ¿ç‰ˆ)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: "Microsoft YaHei", sans-serif; color: #eee; user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI å±‚ */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }

        /* é¡¶éƒ¨é¢æ¿ */
        .top-bar { padding: 20px; background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent); display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }
        .status-box { background: rgba(0, 0, 0, 0.6); padding: 15px; border: 1px solid #444; border-radius: 8px; backdrop-filter: blur(5px); min-width: 200px; }
        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: #d4af37; text-shadow: 0 0 10px #d4af37; }
        .status-text { color: #fff; font-size: 0.9rem; margin-bottom: 5px; }
        .mode-switch { cursor: pointer; padding: 5px 12px; background: #333; border: 1px solid #666; color: white; border-radius: 4px; font-size: 0.8rem; transition: 0.2s; }
        .mode-switch:hover { background: #d4af37; color: #000; }

        /* æ²‰æµ¸æ¨¡å¼ */
        body.immersive #ui-layer { opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        body.immersive #cursor-debug { display: none !important; }
        body.immersive #loader { display: none !important; }
        body.immersive #card-name-reveal { display: block !important; }

        /* å†å²è®°å½• */
        #history-panel { width: 260px; max-height: 40vh; overflow-y: auto; background: rgba(0,0,0,0.7); border: 1px solid #333; border-radius: 8px; padding: 10px; pointer-events: auto; font-size: 0.9rem; }
        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        #history-panel::-webkit-scrollbar { width: 6px; }
        #history-panel::-webkit-scrollbar-thumb { background: #444; border-radius: 3px; }
        .history-item { margin-bottom: 8px; border-bottom: 1px solid #444; padding-bottom: 5px; animation: fadeIn 0.5s ease; }
        .history-name { color: #d4af37; font-weight: bold; }
        .history-meaning { font-size: 0.8rem; color: #aaa; margin-top: 2px; }

        @keyframes fadeIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }

        /* åº•éƒ¨æç¤º */
        .bottom-hint { text-align: center; padding: 20px; text-shadow: 0 0 5px black; font-size: 1.1rem; opacity: 0.8; background: linear-gradient(to top, rgba(0,0,0,0.8), transparent); }

        /* åŠ è½½é®ç½© */
        #loader { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; flex-direction: column; justify-content: center; align-items: center; transition: opacity 0.5s; }
        .spinner { width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #d4af37; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* éšè—è§†é¢‘å…ƒç´  */
        #input-video { display: none; }

        /* ç»“æœå±•ç¤ºå¤§å­— */
        #result-overlay { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; opacity: 0; transition: opacity 0.5s; pointer-events: none; width: 80%; }
        .result-title { font-size: 3rem; color: #d4af37; text-shadow: 0 0 30px rgba(212, 175, 55, 0.5); margin: 0; }
        .result-sub { font-size: 1.4rem; color: #fff; margin-top: 15px; text-shadow: 0 0 10px #000; line-height: 1.4; }

        /* æ¶ˆæ•£æ—¶çš„ç‰Œåæ˜¾ç¤º */
        #card-name-reveal {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 4rem; font-weight: bold; color: transparent;
            background: linear-gradient(135deg, #d4af37 0%, #f4e4ba 25%, #d4af37 50%, #aa8c2c 75%, #d4af37 100%);
            background-size: 200% 200%;
            -webkit-background-clip: text; background-clip: text;
            text-shadow: 0 0 40px rgba(212, 175, 55, 0.8), 0 0 80px rgba(212, 175, 55, 0.4);
            opacity: 0; pointer-events: none; z-index: 50;
            letter-spacing: 8px;
        }
        #card-name-reveal.show {
            animation: revealName 2.5s ease-out forwards, shimmer 2s linear infinite;
        }
        @keyframes revealName {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); filter: blur(20px); }
            30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); filter: blur(0); }
            50% { transform: translate(-50%, -50%) scale(1); }
            80% { opacity: 1; }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(1.2); }
        }
        /* å±•ç¤ºæ—¶ä¿æŒæ˜¾ç¤º */
        #card-name-reveal.showing {
            animation: revealIn 0.8s ease-out forwards, shimmer 2s linear infinite;
        }
        @keyframes revealIn {
            0% { opacity: 0; transform: translate(-50%, -80%) scale(0.5); filter: blur(10px); }
            100% { opacity: 1; transform: translate(-50%, -80%) scale(1); filter: blur(0); }
        }
        @keyframes shimmer {
            0% { background-position: 200% 0; }
            100% { background-position: -200% 0; }
        }

        /* è°ƒè¯•å‡†æ˜Ÿ */
        #cursor-debug { position: absolute; width: 24px; height: 24px; border: 2px solid rgba(255, 255, 255, 0.6); border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; z-index: 20; display: none; box-shadow: 0 0 10px rgba(255,255,255,0.2); transition: background-color 0.1s; }
    </style>

    <!-- Import Maps for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- MediaPipe å®˜æ–¹ç¨³å®šCDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.3/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loader">
    <div class="spinner"></div>
    <p style="margin-top:20px; color:#aaa;">æ­£åœ¨è¿æ¥å‘½è¿ä¹‹çº¿...</p>
</div>

<div id="canvas-container"></div>
<div id="cursor-debug"></div>

<div id="ui-layer">
    <div class="top-bar">
        <div class="status-box">
            <h1>ğŸ”® æ²‰æµ¸å¼å¡”ç½—</h1>
            <div id="status-text" class="status-text">åˆå§‹åŒ–ä¸­...</div>
            <button id="mode-btn" class="mode-switch">åˆ‡æ¢è¾“å…¥æ¨¡å¼</button>
            <button id="immersive-btn" class="mode-switch" style="margin-left:5px;">æ²‰æµ¸æ¨¡å¼ (I)</button>
        </div>
        <div id="history-panel">
            <div style="text-align:center; border-bottom:1px solid #555; margin-bottom:5px; padding-bottom:5px; color:#d4af37;">ğŸ“œ å‘½è¿è®°å½•</div>
            <div id="history-content"></div>
        </div>
    </div>

    <div id="result-overlay">
        <h2 class="result-title" id="res-name"></h2>
        <div class="result-sub" id="res-meaning"></div>
    </div>

    <div class="bottom-hint" id="guide-text">
        åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«ä¸­...
    </div>
</div>

<div id="card-name-reveal"></div>

<video id="input-video"></video>

<script type="module">
    import * as THREE from 'three';

    // ==========================================
    // 1. æ•°æ®é…ç½® (22å¼ å¤§é˜¿å¡çº³)
    // ==========================================
    const TAROT_DATA = [
        { name: "0 æ„šäºº", u: "æ–°çš„å¼€å§‹ï¼Œå†’é™©ï¼Œå¤©çœŸ", r: "é²è½ï¼Œè½»ç‡ï¼Œé£é™©", imgId: 0 },
        { name: "I é­”æœ¯å¸ˆ", u: "åˆ›é€ åŠ›ï¼ŒæŠ€èƒ½ï¼Œæ„å¿—åŠ›", r: "æ¬ºéª—ï¼Œæ²Ÿé€šä¸ç•…", imgId: 1 },
        { name: "II å¥³ç¥­å¸", u: "ç›´è§‰ï¼Œæ½œæ„è¯†ï¼Œç¥ç§˜", r: "å‹æŠ‘ï¼Œæƒ…ç»ªä¸ç¨³å®š", imgId: 2 },
        { name: "III çš‡å", u: "ä¸°é¥¶ï¼Œæ¯æ€§ï¼Œè‡ªç„¶", r: "ä¾èµ–ï¼Œåˆ›é€ åŠ›å—é˜»", imgId: 3 },
        { name: "IV çš‡å¸", u: "æƒå¨ï¼Œç»“æ„ï¼Œæ§åˆ¶", r: "æš´æ”¿ï¼ŒåƒµåŒ–ï¼Œå†·é…·", imgId: 4 },
        { name: "V æ•™çš‡", u: "ä¼ ç»Ÿï¼Œä¿¡ä»°ï¼ŒæŒ‡å¼•", r: "åå›ï¼Œè™šä¼ªï¼Œé™åˆ¶", imgId: 5 },
        { name: "VI æ‹äºº", u: "çˆ±ï¼Œå’Œè°ï¼Œé€‰æ‹©", r: "ä¸å¹³è¡¡ï¼Œåˆ†ç¦»", imgId: 6 },
        { name: "VII æˆ˜è½¦", u: "èƒœåˆ©ï¼Œæ„å¿—ï¼Œæ§åˆ¶", r: "å¤±æ§ï¼Œæ”»å‡»æ€§", imgId: 7 },
        { name: "VIII åŠ›é‡", u: "å‹‡æ°”ï¼Œè€å¿ƒï¼ŒåŒæƒ…", r: "è½¯å¼±ï¼Œè‡ªæˆ‘æ€€ç–‘", imgId: 8 },
        { name: "IX éšå£«", u: "å†…çœï¼Œå­¤ç‹¬ï¼ŒæŒ‡å¼•", r: "å­¤ç«‹ï¼Œè¿·å¤±", imgId: 9 },
        { name: "X å‘½è¿ä¹‹è½®", u: "æ”¹å˜ï¼Œå‘¨æœŸï¼Œå‘½è¿", r: "åè¿æ°”ï¼ŒæŠµæŠ—æ”¹å˜", imgId: 10 },
        { name: "XI æ­£ä¹‰", u: "å…¬å¹³ï¼ŒçœŸç†ï¼Œæ³•å¾‹", r: "ä¸å…¬ï¼Œåè§", imgId: 11 },
        { name: "XII å€’åŠäºº", u: "ç‰ºç‰²ï¼Œæ–°è§†è§’ï¼Œç­‰å¾…", r: "æ— è°“ç‰ºç‰²ï¼Œæ‹–å»¶", imgId: 12 },
        { name: "XIII æ­»ç¥", u: "ç»“æŸï¼Œè½¬å˜ï¼Œé‡ç”Ÿ", r: "åœæ»ï¼Œææƒ§æ”¹å˜", imgId: 13 },
        { name: "XIV èŠ‚åˆ¶", u: "å¹³è¡¡ï¼Œé€‚åº¦ï¼Œè€å¿ƒ", r: "å¤±è¡¡ï¼Œæç«¯", imgId: 14 },
        { name: "XV æ¶é­”", u: "æŸç¼šï¼Œç‰©è´¨ä¸»ä¹‰", r: "é‡Šæ”¾ï¼Œæ‰“ç ´æ·é”", imgId: 15 },
        { name: "XVI é«˜å¡”", u: "çªå˜ï¼Œç¾éš¾ï¼Œå¯ç¤º", r: "é¿å…ç¾éš¾ï¼Œææƒ§", imgId: 16 },
        { name: "XVII æ˜Ÿæ˜Ÿ", u: "å¸Œæœ›ï¼Œçµæ„Ÿï¼Œå¹³é™", r: "ç»æœ›ï¼Œç¼ºä¹ä¿¡å¿ƒ", imgId: 17 },
        { name: "XVIII æœˆäº®", u: "å¹»è§‰ï¼Œææƒ§ï¼Œæ½œæ„è¯†", r: "é‡Šæ”¾ææƒ§ï¼Œæ¸…æ™°", imgId: 18 },
        { name: "XIX å¤ªé˜³", u: "å¿«ä¹ï¼ŒæˆåŠŸï¼Œæ´»åŠ›", r: "æ‚²ä¼¤ï¼Œæš‚æ—¶å—é˜»", imgId: 19 },
        { name: "XX å®¡åˆ¤", u: "å¤æ´»ï¼Œè§‰é†’ï¼Œå®½æ•", r: "è‡ªæˆ‘æ€€ç–‘ï¼Œæ‹’ç»æ”¹å˜", imgId: 20 },
        { name: "XXI ä¸–ç•Œ", u: "å®Œæˆï¼Œæ•´åˆï¼Œæ—…è¡Œ", r: "æœªå®Œæˆï¼Œç¼ºä¹é—­ç¯", imgId: 21 }
    ];

    // æœ¬åœ°å›¾ç‰‡è·¯å¾„ï¼ˆç›¸å¯¹è·¯å¾„ï¼Œé€‚é…Live Serverï¼‰
    const IMG_BASE_URL = "./";
    const RWS_MAP = [
        "1.jpg", "2.jpg", "3.jpg", "4.jpg", "5.jpg", "6.jpg",
        "7.jpg", "8.jpg", "9.jpg", "10.jpg", "11.jpg", "12.jpg",
        "13.jpg", "14.jpg", "15.jpg", "16.jpg", "17.jpg", "18.jpg",
        "19.jpg", "20.jpg", "21.jpg", "22.jpg"
    ];

    // æœ¬åœ°ç‰ŒèƒŒå›¾ç‰‡
    const BACK_IMG_URL = "./bm.jpg";

    // ==========================================
    // 2. Three.js åœºæ™¯åˆå§‹åŒ–
    // ==========================================
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x111111, 0.04);

    const camera3D = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera3D.position.set(0, 0, 8);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    container.appendChild(renderer.domElement);

    // ç¯å…‰
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffd700, 1.0);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);
    const pointLight = new THREE.PointLight(0xaa88ff, 0.8);
    pointLight.position.set(-5, 2, 3);
    scene.add(pointLight);

    // çº¹ç†åŠ è½½å™¨
    const textureLoader = new THREE.TextureLoader();

    // é¢„åŠ è½½ç‰ŒèƒŒ
    const backTexture = textureLoader.load(
        BACK_IMG_URL,
        (tex) => { console.log("âœ… ç‰ŒèƒŒå›¾ç‰‡åŠ è½½æˆåŠŸï¼š", tex); },
        undefined,
        (err) => { console.error("âŒ ç‰ŒèƒŒå›¾ç‰‡åŠ è½½å¤±è´¥ï¼š", err); }
    );

    // ==========================================
    // 3. æ¸¸æˆçŠ¶æ€ç®¡ç†
    // ==========================================
    let gameState = {
        mode: 'HAND', // 'HAND' / 'MOUSE'
        cardMeshes: [],
        cardDataList: [],
        scrollOffset: 0,
        scrollSpeed: 0.07,
        phase: 'IDLE', // IDLE/SCROLLING/SHOWING/FLIPPING/LOADING
        selectedMesh: null,
        selectedData: null,
        selectedIndex: -1,
        isHandOpen: false,
        isFist: false,
        wasFist: false,
        isDragging: false,
        fistCounter: 0,
        openCounter: 0,
        gestureThreshold: 5
    };

    // è½®æ’­å‚æ•°
    const CARD_COUNT = 22;
    const CARD_SPACING = 3.2;
    const TOTAL_WIDTH = CARD_COUNT * CARD_SPACING;

    // UI å…ƒç´ å¼•ç”¨
    const guideText = document.getElementById('guide-text');
    const statusText = document.getElementById('status-text');
    const historyContent = document.getElementById('history-content');
    const cursorDebug = document.getElementById('cursor-debug');
    const resTitle = document.getElementById('res-name');
    const resSub = document.getElementById('res-meaning');
    const resOverlay = document.getElementById('result-overlay');
    const modeBtn = document.getElementById('mode-btn');
    const immersiveBtn = document.getElementById('immersive-btn');
    const videoElement = document.getElementById('input-video');

    // ==========================================
    // 4. ç²’å­ç³»ç»Ÿï¼ˆç‰Œæ¶ˆæ•£æ•ˆæœï¼‰
    // ==========================================
    class AshEffect {
        constructor(position) {
            this.particlesCount = 3000;
            this.geometry = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];
            const colors = [];
            const life = [];

            const w = 4.0, h = 5.5;
            for(let i=0; i<this.particlesCount; i++) {
                positions.push(
                    position.x + (Math.random() - 0.5) * w,
                    position.y + (Math.random() - 0.5) * h,
                    position.z + (Math.random() - 0.5) * 0.3
                );
                
                const angle = Math.random() * Math.PI * 2;
                const upAngle = Math.random() * Math.PI * 0.5;
                const speed = 0.03 + Math.random() * 0.08;
                velocities.push(
                    Math.cos(angle) * Math.cos(upAngle) * speed,
                    Math.sin(upAngle) * speed * 1.5 + 0.02,
                    Math.sin(angle) * Math.cos(upAngle) * speed
                );
                
                const colorChoice = Math.random();
                if (colorChoice < 0.3) colors.push(1.0, 0.85, 0.3); // é‡‘è‰²
                else if (colorChoice < 0.5) colors.push(0.8, 0.5, 1.0); // ç´«è‰²
                else if (colorChoice < 0.7) colors.push(0.4, 0.7, 1.0); // è“è‰²
                else if (colorChoice < 0.85) colors.push(1.0, 1.0, 1.0); // ç™½è‰²
                else colors.push(1.0, 0.6, 0.8); // æ¡ƒçº¢
                
                life.push(1.0 + Math.random() * 0.8);
            }

            this.geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            this.geometry.setAttribute('velocity', new THREE.Float32BufferAttribute(velocities, 3));
            this.geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            this.geometry.setAttribute('life', new THREE.Float32BufferAttribute(life, 1));

            this.material = new THREE.PointsMaterial({
                size: 0.09,
                transparent: true,
                opacity: 1,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            this.mesh = new THREE.Points(this.geometry, this.material);
            this.mesh.frustumCulled = false;
            this.startTime = Date.now();
            scene.add(this.mesh);
        }

        update() {
            const positions = this.geometry.attributes.position.array;
            const velocities = this.geometry.attributes.velocity.array;
            const lives = this.geometry.attributes.life.array;
            let alive = false;
            const elapsed = (Date.now() - this.startTime) * 0.001;

            for(let i=0; i<this.particlesCount; i++) {
                if (lives[i] > 0) {
                    alive = true;
                    
                    // ç²’å­ç§»åŠ¨
                    positions[i*3] += velocities[i*3];
                    positions[i*3+1] += velocities[i*3+1];
                    positions[i*3+2] += velocities[i*3+2];
                    
                    // é‡åŠ›å’Œé˜»åŠ›
                    velocities[i*3] *= 0.98;
                    velocities[i*3+1] -= 0.002;
                    velocities[i*3+2] *= 0.98;
                    
                    // èºæ—‹é£˜åŠ¨
                    const spiral = elapsed * 3 + i * 0.01;
                    positions[i*3] += Math.sin(spiral) * 0.008;
                    positions[i*3+2] += Math.cos(spiral) * 0.008;
                    
                    lives[i] -= 0.006;
                }
            }

            this.material.opacity = Math.max(0, this.material.opacity - 0.005);
            this.geometry.attributes.position.needsUpdate = true;

            if (!alive || this.material.opacity <= 0) {
                scene.remove(this.mesh);
                this.geometry.dispose();
                this.material.dispose();
                return false;
            }
            return true;
        }
    }

    let ashes = [];

    // ==========================================
    // 5. å¡ç‰Œç”Ÿæˆä¸ç®¡ç†
    // ==========================================
    function spawnAllCards() {
        gameState.phase = 'LOADING';
        statusText.innerText = "çŠ¶æ€: æ­£åœ¨å¬å”¤å‘½è¿ä¹‹ç‰Œ...";

        // æ¸…ç†æ—§ç‰Œ
        gameState.cardMeshes.forEach(mesh => {
            if (mesh) {
                scene.remove(mesh);
                mesh.geometry.dispose();
            }
        });
        gameState.cardMeshes = [];
        gameState.cardDataList = [];
        gameState.scrollOffset = 0;
        gameState.selectedMesh = null;
        gameState.selectedData = null;

        // æ‰“ä¹±ç‰Œåº
        const shuffledIndices = Array.from({length: 22}, (_, i) => i);
        for (let i = shuffledIndices.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffledIndices[i], shuffledIndices[j]] = [shuffledIndices[j], shuffledIndices[i]];
        }

        let loadedCount = 0;

        shuffledIndices.forEach((cardId, index) => {
            const cardData = TAROT_DATA[cardId];
            const isReversed = Math.random() < 0.5;
            const imgUrl = IMG_BASE_URL + RWS_MAP[cardData.imgId];

            gameState.cardDataList[index] = { ...cardData, isReversed };

            textureLoader.load(
                imgUrl,
                (tex) => {
                    console.log(`âœ… å¡”ç½—ç‰Œ${cardData.imgId+1}åŠ è½½æˆåŠŸï¼š`, imgUrl);
                    createCarouselCard(tex, index, isReversed);
                    loadedCount++;
                    if (loadedCount === CARD_COUNT) onAllCardsLoaded();
                },
                undefined,
                (err) => {
                    console.warn(`âŒ å¡”ç½—ç‰Œ${cardData.imgId+1}åŠ è½½å¤±è´¥ï¼š`, imgUrl, err);
                    const placeholder = new THREE.CanvasTexture(createPlaceholderCanvas(cardData.name));
                    createCarouselCard(placeholder, index, isReversed);
                    loadedCount++;
                    if (loadedCount === CARD_COUNT) onAllCardsLoaded();
                }
            );
        });
    }

    function createCarouselCard(frontTex, index, isReversed) {
        const geometry = new THREE.BoxGeometry(2.5, 4.0, 0.05);

        frontTex.colorSpace = THREE.SRGBColorSpace;
        backTexture.colorSpace = THREE.SRGBColorSpace;

        const sideMat = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
        const frontMat = new THREE.MeshStandardMaterial({ map: frontTex, roughness: 0.4, metalness: 0.1 });
        const backMat = new THREE.MeshStandardMaterial({ map: backTexture, roughness: 0.6 });

        const materials = [sideMat, sideMat, sideMat, sideMat, frontMat, backMat];
        const mesh = new THREE.Mesh(geometry, materials);

        mesh.userData = { index, isReversed, originalIndex: index, frontTex };
        mesh.position.y = -10;
        mesh.position.z = -2;
        mesh.rotation.y = Math.PI; // é»˜è®¤æ˜¾ç¤ºèƒŒé¢

        scene.add(mesh);
        gameState.cardMeshes[index] = mesh;
    }

    function onAllCardsLoaded() {
        let progress = 0;
        function intro() {
            progress += 0.025;
            const easeOut = 1 - Math.pow(1 - Math.min(progress, 1), 3);

            gameState.cardMeshes.forEach((mesh, i) => {
                if (!mesh) return;
                const targetX = (i - CARD_COUNT / 2) * CARD_SPACING;
                mesh.position.x = targetX;
                mesh.position.y = THREE.MathUtils.lerp(-10, 0, easeOut);
                mesh.position.z = -2;
                
                if (mesh.userData.isReversed) mesh.rotation.z = Math.PI;
            });

            if (progress < 1) requestAnimationFrame(intro);
            else {
                gameState.phase = 'IDLE';
                resetUIForNewRound();
            }
        }
        intro();
    }

    function createPlaceholderCanvas(text) {
        const c = document.createElement('canvas');
        c.width = 256; c.height = 400;
        const ctx = c.getContext('2d');
        ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,256,400);
        ctx.strokeStyle = '#d4af37'; ctx.lineWidth = 10; ctx.strokeRect(5,5,246,390);
        ctx.fillStyle = '#d4af37'; ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center';
        ctx.fillText(text, 128, 180);
        ctx.font = '16px Arial'; ctx.fillStyle = '#888';
        ctx.fillText("Image Unavailable", 128, 220);
        return c;
    }

    function resetUIForNewRound() {
        resOverlay.style.opacity = 0;
        statusText.innerText = gameState.mode === 'HAND'
            ? "çŠ¶æ€: å¼ å¼€æ‰‹æŒå¼€å§‹æ»šåŠ¨"
            : "çŠ¶æ€: æŒ‰ä½å·¦é”®å¼€å§‹æ»šåŠ¨";
        guideText.innerText = gameState.mode === 'HAND'
            ? "ğŸ– å¼ å¼€=æ»šåŠ¨ | âœŠ æ¡æ‹³=æŠ½å– | æ¾å¼€=æ¶ˆæ•£"
            : "ğŸ–± æŒ‰ä½=æ»šåŠ¨ | åŒå‡»=æŠ½å– | å†æ¬¡åŒå‡»=æ¶ˆæ•£";
    }

    // ==========================================
    // 6. è½®æ’­æ›´æ–°é€»è¾‘
    // ==========================================
    function updateCarousel() {
        gameState.cardMeshes.forEach((mesh, i) => {
            if (!mesh || mesh === gameState.selectedMesh) return;

            let baseX = (i - CARD_COUNT / 2) * CARD_SPACING;
            let x = baseX + gameState.scrollOffset;
            
            // å¾ªç¯æ»šåŠ¨å¤„ç†
            while (x > TOTAL_WIDTH / 2) x -= TOTAL_WIDTH;
            while (x < -TOTAL_WIDTH / 2) x += TOTAL_WIDTH;

            mesh.position.x = x;
            mesh.position.z = -2;
            
            // ä¸­é—´ç‰Œæ”¾å¤§æ•ˆæœ
            const distFromCenter = Math.abs(x);
            const scale = THREE.MathUtils.lerp(1.15, 0.9, Math.min(distFromCenter / 8, 1));
            const zOffset = THREE.MathUtils.lerp(1, 0, Math.min(distFromCenter / 8, 1));
            
            mesh.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.15);
            mesh.position.z = THREE.MathUtils.lerp(mesh.position.z, -2 + zOffset, 0.15);
            mesh.position.y = THREE.MathUtils.lerp(mesh.position.y, 0, 0.1);
        });
    }

    function getCenterCard() {
        let closest = null;
        let minDist = Infinity;
        gameState.cardMeshes.forEach((mesh, i) => {
            if (!mesh) return;
            const dist = Math.abs(mesh.position.x);
            if (dist < minDist) {
                minDist = dist;
                closest = { mesh, index: i, data: gameState.cardDataList[i] };
            }
        });
        return closest;
    }

    // ==========================================
    // 7. äº¤äº’æ ¸å¿ƒé€»è¾‘
    // ==========================================
    function updateInteraction() {
        if (gameState.cardMeshes.length === 0 || gameState.phase === 'LOADING') return;
        
        if (gameState.phase === 'FLIPPING') {
            gameState.wasFist = gameState.isFist;
            return;
        }

        updateCarousel();

        // æ»šåŠ¨/æŠ½å–é€»è¾‘
        if (gameState.phase === 'IDLE' || gameState.phase === 'SCROLLING') {
            if (gameState.isHandOpen || gameState.isDragging) {
                gameState.scrollOffset += gameState.scrollSpeed;
                gameState.phase = 'SCROLLING';
                statusText.innerText = "çŠ¶æ€: å‘½è¿ä¹‹è½®è½¬åŠ¨ä¸­... æ¡æ‹³æŠ½å–!";
            } else {
                gameState.phase = 'IDLE';
                if (gameState.mode === 'HAND') {
                    statusText.innerText = "çŠ¶æ€: å¼ å¼€æ‰‹æŒå¼€å§‹æ»šåŠ¨";
                }
            }

            // æ¡æ‹³æŠ½å–ç‰Œ
            if (gameState.isFist && !gameState.wasFist) {
                selectCard();
            }
        }
        else if (gameState.phase === 'SHOWING') {
            // æ¾å¼€æ‹³å¤´æ¶ˆæ•£ç‰Œ
            if (!gameState.isFist && gameState.wasFist) {
                dismissCard();
            }
        }

        gameState.wasFist = gameState.isFist;
    }

    function selectCard() {
        const center = getCenterCard();
        if (!center) return;

        gameState.phase = 'FLIPPING';
        gameState.selectedMesh = center.mesh;
        gameState.selectedData = center.data;
        gameState.selectedIndex = center.index;

        const mesh = center.mesh;
        const isRev = center.data.isReversed;
        
        // ç¿»ç‰ŒåŠ¨ç”»
        let flipProgress = 0;
        const startRotY = mesh.rotation.y;
        const targetRotY = 0;
        const startPos = mesh.position.clone();
        const startScale = mesh.scale.x;
        const startRotZ = mesh.rotation.z;
        const targetRotZ = isRev ? Math.PI : 0;
        
        function flipAnimation() {
            flipProgress += 0.03;
            const ease = 1 - Math.pow(1 - Math.min(flipProgress, 1), 3);
            
            mesh.rotation.y = THREE.MathUtils.lerp(startRotY, targetRotY, ease);
            mesh.rotation.z = THREE.MathUtils.lerp(startRotZ, targetRotZ, ease);
            
            mesh.position.x = THREE.MathUtils.lerp(startPos.x, 0, ease);
            mesh.position.y = THREE.MathUtils.lerp(startPos.y, 0.5, ease);
            mesh.position.z = THREE.MathUtils.lerp(startPos.z, 4, ease);
            mesh.scale.setScalar(THREE.MathUtils.lerp(startScale, 1.2, ease));
            
            if (flipProgress < 1) requestAnimationFrame(flipAnimation);
            else {
                gameState.phase = 'SHOWING';
                showResult();
            }
        }
        flipAnimation();
        
        statusText.innerText = "çŠ¶æ€: ç¿»å¼€å‘½è¿ä¹‹ç‰Œ...";
    }
    
    function showResult() {
        const data = gameState.selectedData;
        const isRev = data.isReversed;
        const titleStr = data.name + (isRev ? " (é€†ä½)" : " (æ­£ä½)");
        const meaningStr = isRev ? data.r : data.u;

        // æ˜¾ç¤ºç‰ŒååŠ¨ç”»
        const nameReveal = document.getElementById('card-name-reveal');
        nameReveal.textContent = data.name;
        nameReveal.classList.remove('show');
        nameReveal.classList.add('showing');

        // æ›´æ–°ç»“æœUI
        resTitle.innerText = titleStr;
        resTitle.style.color = isRev ? "#aaa" : "#d4af37";
        resSub.innerText = meaningStr;
        resOverlay.style.opacity = 1;

        // æ·»åŠ å†å²è®°å½•
        const div = document.createElement('div');
        div.className = 'history-item';
        div.innerHTML = `<div class="history-name">${titleStr}</div><div class="history-meaning">${meaningStr}</div>`;
        historyContent.prepend(div);

        statusText.innerText = "çŠ¶æ€: å‘½è¿å·²æ­æ™“! æ¾å¼€æ‹³å¤´ç»§ç»­...";
    }

    function dismissCard() {
        if (!gameState.selectedMesh) return;

        const mesh = gameState.selectedMesh;
        const idx = gameState.cardMeshes.indexOf(mesh);
        const cardName = gameState.selectedData ? gameState.selectedData.name : '';

        // ç‰Œåæ¶ˆæ•£åŠ¨ç”»
        const nameReveal = document.getElementById('card-name-reveal');
        nameReveal.textContent = cardName;
        nameReveal.classList.remove('showing');
        nameReveal.classList.remove('show');
        void nameReveal.offsetWidth; // å¼ºåˆ¶é‡ç»˜
        nameReveal.classList.add('show');

        // ç²’å­æ•ˆæœ
        ashes.push(new AshEffect(mesh.position.clone()));
        scene.remove(mesh);
        if (idx >= 0) gameState.cardMeshes[idx] = null;

        gameState.selectedMesh = null;
        gameState.selectedData = null;
        resOverlay.style.opacity = 0;

        statusText.innerText = "çŠ¶æ€: å‡†å¤‡ä¸‹ä¸€è½®...";

        // é‡æ–°ç”Ÿæˆç‰Œç»„
        setTimeout(() => {
            nameReveal.classList.remove('show');
            spawnAllCards();
        }, 2500);
    }

    // ==========================================
    // 8. è¾“å…¥å¤„ç†ï¼ˆé¼ æ ‡+æ‰‹åŠ¿ï¼‰
    // ==========================================
    // é¼ æ ‡æ¨¡å¼
    function initMouseInput() {
        window.addEventListener('mousemove', (e) => {
            if (gameState.mode !== 'MOUSE') return;
            const mouseVector = new THREE.Vector2();
            mouseVector.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouseVector.y = -(e.clientY / window.innerHeight) * 2 + 1;
        });

        window.addEventListener('mousedown', () => {
            if(gameState.mode === 'MOUSE') gameState.isDragging = true;
        });

        window.addEventListener('mouseup', () => {
            if(gameState.mode === 'MOUSE') gameState.isDragging = false;
        });

        window.addEventListener('dblclick', () => {
            if(gameState.mode !== 'MOUSE') return;
            
            if (gameState.phase === 'SHOWING') {
                gameState.isFist = false;
                gameState.wasFist = true;
            } else {
                gameState.isFist = true;
                gameState.wasFist = false;
            }
        });
    }

    // åˆ‡æ¢è¾“å…¥æ¨¡å¼
    modeBtn.addEventListener('click', () => {
        if (gameState.mode === 'HAND') {
            enableMouseMode();
        } else {
            location.reload();
        }
    });

    // æ²‰æµ¸æ¨¡å¼
    immersiveBtn.addEventListener('click', toggleImmersive);
    window.addEventListener('keydown', (e) => {
        if (e.key === 'i' || e.key === 'I') toggleImmersive();
    });
    
    function toggleImmersive() {
        document.body.classList.toggle('immersive');
    }

    function enableMouseMode() {
        gameState.mode = 'MOUSE';
        modeBtn.innerText = "å½“å‰: é¼ æ ‡ (ç‚¹å‡»åˆ·æ–°åˆ‡å›æ‘„åƒå¤´)";
        guideText.innerText = "ğŸ–± æŒ‰ä½=æ»šåŠ¨ | åŒå‡»=æŠ½å– | å†æ¬¡åŒå‡»=æ¶ˆæ•£";
        statusText.innerText = "å·²åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼";
        cursorDebug.style.display = 'none';
    }

    // ==========================================
    // 9. æ‰‹åŠ¿è¯†åˆ«æ ¸å¿ƒï¼ˆå®Œæ•´ä¿®å¤ï¼‰
    // ==========================================
    function initHandTracking() {
        // æ‰‹åŠ¿ç»“æœå¤„ç†
        function onResults(results) {
            if (gameState.mode !== 'HAND') return;
            document.getElementById('loader').style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];

                // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»
                let tipsDist = 0;
                const tipIndices = [4, 8, 12, 16, 20];
                tipIndices.forEach(idx => {
                    tipsDist += Math.hypot(landmarks[idx].x - wrist.x, landmarks[idx].y - wrist.y);
                });
                const avgDist = tipsDist / 5;

                // æ‰‹åŠ¿åˆ¤æ–­
                const rawFist = avgDist < 0.22;
                const rawOpen = avgDist > 0.28;
                
                // é˜²æŠ–
                if (rawFist) {
                    gameState.fistCounter++;
                    gameState.openCounter = 0;
                } else if (rawOpen) {
                    gameState.openCounter++;
                    gameState.fistCounter = 0;
                } else {
                    gameState.fistCounter = Math.max(0, gameState.fistCounter - 1);
                    gameState.openCounter = Math.max(0, gameState.openCounter - 1);
                }
                
                // æ›´æ–°çŠ¶æ€
                gameState.isFist = gameState.fistCounter >= gameState.gestureThreshold;
                gameState.isHandOpen = gameState.openCounter >= gameState.gestureThreshold;

                // è°ƒè¯•å‡†æ˜Ÿ
                cursorDebug.style.display = 'block';
                cursorDebug.style.left = '50%';
                cursorDebug.style.top = '85%';
                
                if (gameState.isFist) {
                    cursorDebug.style.borderColor = 'red';
                    cursorDebug.style.backgroundColor = 'rgba(255,0,0,0.4)';
                    cursorDebug.style.boxShadow = '0 0 20px red';
                } else if (gameState.isHandOpen) {
                    cursorDebug.style.borderColor = '#0f0';
                    cursorDebug.style.backgroundColor = 'rgba(0,255,0,0.3)';
                    cursorDebug.style.boxShadow = '0 0 20px #0f0';
                } else {
                    cursorDebug.style.borderColor = 'yellow';
                    cursorDebug.style.backgroundColor = 'transparent';
                    cursorDebug.style.boxShadow = 'none';
                }
            } else {
                // æ— æ‰‹éƒ¨æ£€æµ‹æ—¶é‡ç½®
                gameState.isHandOpen = false;
                gameState.isFist = false;
                gameState.fistCounter = 0;
                gameState.openCounter = 0;
                cursorDebug.style.display = 'none';
            }
        }

        // åˆå§‹åŒ–Hands
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`
        });
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });
        hands.onResults(onResults);

        // åˆå§‹åŒ–æ‘„åƒå¤´ï¼ˆä¿®å¤å˜é‡åå†²çªï¼‰
        const handCamera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        // å¯åŠ¨æ‘„åƒå¤´
        handCamera.start().then(() => {
            console.log("âœ… æ‘„åƒå¤´å¯åŠ¨æˆåŠŸï¼Œæ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª");
            statusText.innerText = "çŠ¶æ€: æ‰‹åŠ¿è¯†åˆ«å·²å°±ç»ª";
            guideText.innerText = "ğŸ– å¼ å¼€=æ»šåŠ¨ | âœŠ æ¡æ‹³=æŠ½å– | æ¾å¼€=æ¶ˆæ•£";
        }).catch(err => {
            console.error("âŒ æ‘„åƒå¤´å¯åŠ¨å¤±è´¥ï¼š", err);
            document.getElementById('loader').style.display = 'none';
            alert("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥æˆ–è¢«æ‹’ç»ï¼Œè‡ªåŠ¨åˆ‡æ¢è‡³é¼ æ ‡æ¨¡å¼ã€‚\n\nè§£å†³æ–¹æ³•ï¼š\n1. å…è®¸æµè§ˆå™¨è®¿é—®æ‘„åƒå¤´\n2. åˆ·æ–°é¡µé¢é‡è¯•");
            enableMouseMode();
        });
    }

    // ==========================================
    // 10. ä¸»å¾ªç¯
    // ==========================================
    function animate() {
        requestAnimationFrame(animate);
        updateInteraction();

        // æ›´æ–°ç²’å­æ•ˆæœ
        if (ashes.length > 0) {
            ashes = ashes.filter(ash => ash.update());
        }

        renderer.render(scene, camera3D);
    }

    // çª—å£å¤§å°é€‚é…
    window.addEventListener('resize', () => {
        camera3D.aspect = window.innerWidth / window.innerHeight;
        camera3D.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // åˆå§‹åŒ–
    initMouseInput();
    initHandTracking();
    spawnAllCards();
    animate();
</script>
</body>
</html>